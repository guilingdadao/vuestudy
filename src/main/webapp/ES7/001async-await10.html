<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>练习生命周期</title>
</head>

<body>

	<script type="text/javascript">
	/**
	 *  包裹一个promise函数
	 
	 ***/
	 function printMsg(name){
		
		return  new Promise(resolve=>{
				
			window.setTimeout(function(){
				resolve(" $"+name+"$ ");
			},1000);
		});
	}
	 
/***
Generator函数是一个状态机，封装了多个内部状态。
Generator函数除了状态机，还是一个遍历器对象生成函数

一是，function关键字与函数名之间有一个星号；
二是，函数体内部使用yield语句，定义不同的内部状态

调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象


必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，
内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。
换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行


*/
 function *doBach(){
// 	next()方法返回一个对象，它的value属性就是当前yield语句的值
//next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined）
	yield printMsg('zhangsan');
// 	yield let name2 =printMsg(name1);
// 	yield let name3 =printMsg(name3);
}

 let ret = doBach();
 
ret.next().value.then(function(msg){
	 console.log(msg);
 });

</script>

</body>
</html>